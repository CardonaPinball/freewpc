#!/usr/bin/perl
#
# Copyright 2006 by Brian Dominy <brian@oddchange.com>
#
# This file is part of FreeWPC.
#
# FreeWPC is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# FreeWPC is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with FreeWPC; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# ------------------------------------------------------------------
# genmachine - autogenerate declarations from machine description
# ------------------------------------------------------------------

use Data::Dumper;

my $contextName = "";
my $m = {};
my $mc = $m;
my $autoid;

my $GLOBAL_OBJECT = 2;

my %contextDefinitionRe = (
	"" => ".*",
	"switches" => "[1-8FD][1-8]",
	"lamps" => "[1-8][1-8]",
	"drives" => "[HLGAX][1-8]",
	"gi" => "[0-9]+",
	"lampsets" => "AUTO",
	"containers" => "AUTO",
	"shots" => "AUTO",
	"drivers" => "AUTO",
	"tests" => "AUTO",
	"deffs" => "AUTO",
	"leffs" => "AUTO",
	"adjustments" => "AUTO",
	"audits" => "AUTO",
	"system_sounds" => "AUTO",
	"system_music" => "AUTO",
	"highscores" => "GC|1|2|3|4",
	"flags" => "AUTO",
	"scores" => "AUTO",
);

my %BinaryProperties = (
	"switches" => { 
		"button" => 1,
		"service" => 1,
		"micro" => 1,
		"opto" => 1, 
		"device" => 1, 
		"virtual" => 1,
		"drain-switch" => 1,
		"standup" => 1,
		"fast" => 1,
		"edge" => 1,
		"outhole" => $GLOBAL_OBJECT,
		"shooter" => $GLOBAL_OBJECT,
		"tilt" => $GLOBAL_OBJECT,
		"slam-tilt" => $GLOBAL_OBJECT,
		"buyin-button" => $GLOBAL_OBJECT,
		"launch-button" => $GLOBAL_OBJECT,
		"start-button" => $GLOBAL_OBJECT,
	},
	"lamps" => {
		"start" => $GLOBAL_OBJECT,
		"buyin" => $GLOBAL_OBJECT,
	},
	"drives" => {
		"ballserve" => $GLOBAL_OBJECT,
		"knocker" => $GLOBAL_OBJECT,
		"motor" => 1,
		"magnet" => 1,
		"popper" => 1,
		"upkick" => 1,
		"eject" => 1,
		"flash" => 1,
		"nosearch" => 1,
	},
	"containers" => {
		"trough" => $GLOBAL_OBJECT,
	},
	"deffs" => {
		"amode" => $GLOBAL_OBJECT,
		"runner" => 1,
	},
	"leffs" => {
		"amode" => $GLOBAL_OBJECT,
		"runner" => 1,
	},
);

my %EnumeratedProperties = (
	"lamps" => {
		"color" => {
			"amber" => 1,
			"white" => 1,
			"red" => 1, 
			"orange" => 1, 
			"yellow" => 1,
			"green" => 1,
			"blue" => 1,
		},
	},
	"adjustments" => {
		"type" => {
			"integer" => 1,
			"yes_no" => 1,
			"on_off" => 1,
			"score" => 1,
			"percent" => 1,
			"credit_count" => 1,
		},
	},
);

my %ContextPrefixes = (
	"switches" => "SW",
	"lamps" => "LM",
	"lampsets" => "LMSET",
	"drives" => "SOL",
	"gi" => "GI",
	"containers" => "DEVNO",
	"shots" => "SHOT",
	"flags" => "FLAG",
);

my %ContextMaxima = (
	"containers" => "NUM_DEVICES",
	"shots" => "NUM_SHOTS",
	"flags" => "MAX_FLAGS",
);


sub unique {
	my ($category) = @_;
	my @result;
	my $integer = 1;
	foreach $defname (keys %$category) {
		my $def = $category->{$defname};
		next if ($defname ne $def->{'ID'});
		push @result, $def;
		$integer = 0 if (!($def->{'number'} =~ m/^[0-9]/));
	}
	if ($integer) {
		@result = sort { $a->{'number'} <=> $b->{'number'} } @result;
	} else {
		@result = sort { $a->{'ID'} cmp $b->{'ID'} } @result;
	}
	return @result;
}

sub check_define_global {
	my ($context, $def) = @_;
	my $props = $BinaryProperties{$context};

	foreach $propname (keys %$props) {
		if ($props->{$propname} == $GLOBAL_OBJECT) {
			if (defined $def->{$propname}) {
				$m->{"*${context}:${propname}"} = $def;
			}
		}
	}
}

sub close_switch_or_lamp {
	my ($def) = @_;
	$def->{'ID'} =~ m/(.)(.)/;
	my ($first, $second) = ($1, $2);
	if ($first eq "D") {
		$def->{'number'} = $second - 1;
	}
	elsif ($first eq "F") {
		$def->{'number'} = 72 + $second - 1;
	}
	elsif ($def->{'c_ident'} =~ /^SW_/) {
		$def->{'number'} = 8 + ($first - 1) * 8 + $second - 1;
	}
	else {
		$def->{'number'} = ($first - 1) * 8 + $second - 1;
	}
}

sub close_switch {
	my ($def) = @_;
	close_switch_or_lamp ($def);
}

sub close_drive {
	my ($drive) = @_;
	$drive->{'ID'} =~ m/(.)(.)/;
	$drive->{'number'} = $2 - 1; # assume 'H'
	$drive->{'number'} += 8 if ($1 eq "L");
	$drive->{'number'} += 16 if ($1 eq "G");
	$drive->{'number'} += 24 if ($1 eq "A");
	$drive->{'number'} += 40 if ($1 eq "X");
	$drive->{'c_ident'} =~ s/^SOL_/FLASH_/ if (defined $drive->{'flash'});
}

sub close_container {
	my ($container) = @_;
	my ($coilname, @switchnames) = split /,[ \t]*/, $container->{'props'};
	$container->{'coil'} = $coilname;
	$container->{'size'} = scalar @switchnames;
	$container->{'switches'} = \@switchnames;
	foreach $sw (@switchnames) {
		(($m->{"switches"})->{$sw})->{"container"} = $container;
	}
	$container->{'init_max_count'} = 0 if (!defined $container->{'init_max_count'});
}

sub close_gi {
	my ($gi) = @_;
	$gi->{'number'} = "TRIAC_GI_STRING(" .
		$gi->{'ID'} . ")";
}

my %ContextClosures = (
	"switches" => \&close_switch,
	"lamps" => \&close_switch_or_lamp,
	"drives" => \&close_drive,
	"containers" => \&close_container,
	"gi" => \&close_gi,
);


####################################################################
#
# machine_load
#
# Load a machine description and parse into the internal format.
#
####################################################################
sub machine_load {
	my ($file) = @_;
	open FH, $file or die;
	my $lineno = 0;
LINE: 
	while (<FH>) {
		$lineno++;
		# Remove newline character
		chomp;
		# Remove leading/trailing spaces and tabs
		s/^[ \t]//; s/[ \t]$//;
		# Ignore comments and blank lines
		next if /^#/; next if /^$/;
		# Join with following line if necessary
		while (/\\$/) {
			my $line = <FH>;
			s/\\$//;
			$_ .= $line;
			chomp;
			$lineno++;
		}

		# Check for a literal define
		if (/^define[ \t]+(.*)/) {
			if (!defined ($m->{'Extra-Defines'})) {
				$m->{'Extra-Defines'} = [];
			}
			my $arrayref = $m->{'Extra-Defines'};
			push @$arrayref, $1;
			next;
		}

		# Check for a context change
		if (/^\[(.*)\]$/) {
			$contextName = $1;
			if (!defined $m->{$contextName}) { $m->{$contextName} = {}; }
			$mc = $m->{$contextName};
			$autoid = 0;
			next;
		}

		# Check for a data definition.  The syntax depends on the context.
		my $re = $contextDefinitionRe{$contextName};
		if (($re eq "AUTO") || (/^($re):(.*)$/)) {
			my ($ID, $parms, $name);
			if ($re eq "AUTO") {
				/^([^:]+):(.*)$/;
				($ID, $parms, $name) = ($autoid++, $2, $1);
			}
			else {
				($ID, $parms, $name) = ($1, $2, undef);
			}
			my $def = $mc->{$ID} = {};
			$def->{'ID'} = $def->{'number'} = $ID;
			$mc->{$name} = $def if ((defined $name) && ($name ne $ID));
			$def->{'name'} = $name;

			# Parse the parameters to the definition
			my @parmlist = split /,/, $parms;
			PARM: foreach $parm (@parmlist) {
				$parm =~ s/^[ \t]//; $parm =~ s/[ \t]$//;

				# The first parm is always the name
				if (!defined $def->{'name'}) {
					$mc->{$parm} = $def;
					$def->{'name'} = $parm;
					next;
				}

				# Is it a binary property?
				my $binprops = $BinaryProperties{$contextName};
				if (defined $binprops->{$parm}) {
					$def->{$parm} = $binprops->{$parm};
					next PARM;
				}

				# Is it an enumerated property?
				my $enumprops = $EnumeratedProperties{$contextName};
				foreach $epropname (keys %$enumprops) {
					my $eprop = $enumprops->{$epropname};
					if (defined $eprop->{$parm}) {
						$def->{$epropname} = $parm;
						next PARM;
					}
				}

				# Is the field stated explicitly?
				if ($parm =~ /(.*)\((.*)\)/) {
					$def->{$1} = $2;
					next;
				}

				# Any other property is added to the default list
				if (defined $def->{'props'}) {
					$def->{'props'} .= ",$parm";
				} else {
					$def->{'props'} = "$parm";
				}
			}

			# Derive C strings from the human readable name
			my $c_string = $def->{'name'};
			$c_string =~ tr/a-z/A-Z/;
			$def->{'c_string'} = "\"$c_string\"";

			my $c_ident = $c_string;
			$c_ident =~ s/[ :-]+/_/g;
			$c_ident =~ s/[.\']//g;
			my $prefix = $ContextPrefixes{$contextName};
			if (defined $prefix) {
				$prefix .= "_";
			} else {
				$prefix = "";
			}
			my $c_ident = $def->{'c_ident'} = $prefix . $c_ident;
			$c_ident =~ tr/A-Z/a-z/;
			$def->{'c_decl'} = $c_ident;

			# Invoke the closure if there is one
			if (defined $ContextClosures{$contextName}) {
				$ContextClosures{$contextName} ($def);
			}

			check_define_global ($contextName, $def);

			next;
		}

		else {
			# Handle lines that aren't data definitions.
			die "Unrecognized element at line " . $lineno . "\n";
		}
	}
	close FH;

	#----------------------------------------------------------------
	# After loading the file, certain transformations may need to be
	# made to the data, after everything is known.  Do those here.
	#----------------------------------------------------------------

	# Any switch that is part of a container should be marked as an
	# edge switch
	foreach $cnt (unique ($m->{"containers"})) {
		my $sws = $cnt->{'switches'};
		foreach $swname (@$sws) {
			my $sw = ($m->{'switches'})->{$swname};
			if (!defined $sw) { die "$swname is not a valid switch name"; }
			$sw->{'edge'} = 1;
		}
	}

	# Does the machine have upper flippers that need to be serviced?
	$m->{'*switches:has-ul'} = 1;
	$m->{'*switches:has-ur'} = 1;
}


sub machine_dump {
	print "\n/* Internal database representation */\n";
	print "/* " . Dumper ($m) . "*/\n";
}

sub print_boolean {
	my ($def, $symbol) = @_;
	if (defined $def && $def->{'name'} =~ /[yY]es/) {
		print "#define $symbol 1\n";
	} else {
		print "#define $symbol 0\n";
	}
}

sub print_value {
	my ($def, $symbol) = @_;
	if (defined $def && defined $def->{'name'}) {
		my $value = $def->{'name'};
		$value =~ tr/a-z/A-Z/;
		print "#define $symbol \"" . $value . "\"\n";
	}
}

sub print_define {
	my ($def, $symbol) = @_;
	if (defined $def) {
		print "#define $symbol\n";
	} else {
		print "#undef $symbol\n";
	}
}

sub print_c_ident {
	my ($def, $symbol) = @_;
	if (defined $def) {
		my $value = $def->{'c_ident'};
		print "#define $symbol $value\n";
	} else {
		print "#undef $symbol\n";
	}
}

sub machine_write_defines {
	# Print object IDs
	foreach $context (keys %ContextPrefixes) {
		my $mc = $m->{$context};
		my $indexRe = $contextDefinitionRe{$context};
		my $number;
		$indexRe = "[0-9]+" if ($indexRe eq "AUTO");
		print "/* Definitions of $context */\n";
		foreach my $def (unique ($mc)) {
			$number = $def->{'number'};
			print "#define " . $def->{'c_ident'} . " " .  $number . "\n";
		}
		my $max = $ContextMaxima{$context};
		if (defined $max) {
			$number++;
			print "#define $max $number\n";
		}
		print "\n";
	}

	# Print extra defines
	print "/* Extra defines */\n";
	if (defined ($extra_defs = $m->{'Extra-Defines'})) {
		foreach $def (@$extra_defs) {
			print "#define $def\n";
		}
	}
	print "\n";

	# Print machine configuration
	print "/* Global configuration */\n";
	print_value ($m->{'Title'}, "MACHINE_NAME");
	print_boolean ($m->{'DMD'}, "MACHINE_DMD");
	print_boolean ($m->{'Fliptronic'}, "MACHINE_FLIPTRONIC");
	print_boolean ($m->{'DCS'}, "MACHINE_DCS");
	print_boolean ($m->{'WPC95'}, "MACHINE_WPC95");
	print_define ($m->{'*switches:has-ul'}, "MACHINE_HAS_UPPER_LEFT_FLIPPER");
	print_define ($m->{'*switches:has-ur'}, "MACHINE_HAS_UPPER_RIGHT_FLIPPER");

	print_c_ident ($m->{'*switches:shooter'}, "MACHINE_SHOOTER_SWITCH");
	print_c_ident ($m->{'*switches:tilt'}, "MACHINE_TILT_SWITCH");
	print_c_ident ($m->{'*switches:slam-tilt'}, "MACHINE_SLAM_TILT_SWITCH");
	print_c_ident ($m->{'*switches:start-button'}, "MACHINE_START_SWITCH");
	print_c_ident ($m->{'*switches:buyin-button'}, "MACHINE_BUYIN_SWITCH");
	print_c_ident ($m->{'*switches:launch-button'}, "MACHINE_LAUNCH_SWITCH");
	print_c_ident ($m->{'*switches:outhole'}, "MACHINE_OUTHOLE_SWITCH");
	
	print_c_ident ($m->{'*lamps:start'}, "MACHINE_START_LAMP");
	print_c_ident ($m->{'*lamps:buyin'}, "MACHINE_BUYIN_LAMP");

	print_c_ident ($m->{'*drives:launch'}, "MACHINE_LAUNCH_SOLENOID");
	print_c_ident ($m->{'*drives:knocker'}, "MACHINE_KNOCKER_SOLENOID");
	print_c_ident ($m->{'*drives:ballserve'}, "MACHINE_BALL_SERVE_SOLENOID");

	my $trough = $m->{'*containers:trough'};
	my $troughsize = $trough->{'size'};
	print "#define MACHINE_TROUGH_SIZE $troughsize\n";
	my $troughsws = $trough->{'switches'};
	foreach $swname (@$troughsws) {
		$n++;
		my $sw = ($m->{"switches"})->{$swname};
		print "#define MACHINE_TROUGH$n " . $sw->{'c_ident'} . "\n";
	}

	# Print MACHINE_SOL_FLASHERP(sol), which returns true if SOL is
	# a flasher.
	my $drives = $m->{"drives"};
	print "#define MACHINE_SOL_FLASHERP(sol) (\\\n";
	foreach $drive (unique (%$drives)) {
		if (defined $drive->{'flash'}) {
			print "   ((sol) == " . $drive->{'c_ident'} . ") || \\\n";
		}
	}
	print "0)\n\n";

	# Print MACHINE_SOL_NOSEARCHP(sol), which returns true if SOL should
	# not be fired during ball search.  Flashers need not be considered.
	print "#define MACHINE_SOL_NOSEARCHP(sol) (\\\n";
	foreach $drive (unique (%$drives)) {
		my $drive = $drives->{$drivename};
		if (defined $drive->{'nosearch'}) {
			print "   ((sol) == " . $drive->{'c_ident'} . ") || \\\n";
		}
	}
	print "0)\n\n";

	# Print MACHINE_xxMS_RTTS defines
	my @pollcounts = (1, 8, 32, 128);
	my $drivers = $m->{"drivers"};
	for $poll (@pollcounts) {
		my @calls = ();
		for $drv (unique ($drivers)) {
			my $drv = $drivers->{$drvkey};
			my $drvname = $drv->{'name'};
			if ($drv->{'poll'} == $poll) {
				push @calls, "   VOIDCALL(${drvname}_rtt) \\";
			}
		}
		if (@calls) {
			print "#define MACHINE_${poll}MS_RTTS \\\n";
			foreach my $call (@calls) {
				print "$call\n";
			}
			print "\n";
		} else {
			print "#undef MACHINE_${poll}MS_RTTS\n";
		}
	}
	print "\n";

	# Print feature_adj_t and MACHINE_FEATURE_ADJUSTMENTS
	print "typedef struct {\n";
	foreach $feature (unique ($m->{"adjustments"})) {
		my $ident = $feature->{'c_decl'};
		print "   U8 $ident;\n";
	}
	print "} feature_adj_t;\n\n";

	print "#define MACHINE_FEATURE_ADJUSTMENTS \\\n";
	foreach $feature (unique ($m->{"adjustments"})) {
		my $ident = $feature->{'c_decl'};
		my $type = $feature->{'type'};
		my $default = $feature->{'props'};
		my $string = $feature->{'c_string'};
		print "  { $string, \&${type}_value, $default, \&feature_config.$ident }, \\\n";
	}
	print "\n\n";


	# Print MACHINE_TEST_MENU_ITEMS
	my $tests = $m->{"tests"};
	print "#define MACHINE_TEST_MENU_ITEMS \\\n";
	foreach $test (unique ($tests)) {
		my $ident = $test->{'c_decl'};
		print "   \&${ident}_test_item, \\\n";
	}
	print "\n";
	foreach $test (unique ($tests)) {
		my $ident = $test->{'c_decl'};
		print "extern struct menu ${ident}_test_item;\n";
	}
	print "\n";

	# Print system sounds and music
	foreach my $snd (unique ($m->{"system_sounds"})) {
		my $id = $snd->{'c_ident'};
		my $value = $snd->{'props'};
		print "#define MACHINE_${id}_SOUND $value\n";
	}
	foreach my $mus (unique ($m->{"system_music"})) {
		my $id = $mus->{'c_ident'};
		my $value = $mus->{'props'};
		print "#define MACHINE_${id}_MUSIC $value\n";
	}
	print "\n";
}


sub machine_write_decl_names {
	my ($categoryname) = @_;
	print "const char *names_of_${categoryname} [] = {\n";
	foreach $def (unique ($m->{$categoryname})) {
		my $ident = $def->{'c_ident'};
		my $string = $def->{'c_string'};
		print "   [$ident] = $string,\n";
	}
	print "};\n\n";
}


@stringcontexts = ("switches", "drives", "lamps", "containers");

my $START_SOURCE = <<END;
/* Autogenerated from $infile by genmachine */

#include <freewpc.h>

END

my $END_SOURCE = "\n";

$infile = $ARGV[0] or "machine/tz/tz.md";
$command = $ARGV[1];

machine_load ($infile);

#######################################################
#  generate build/mach-config.h
#######################################################
if ($command eq "config") {
	print "#ifndef _MACH_CONFIG_H\n";
	print "#define _MACH_CONFIG_H\n";
	
	machine_write_defines ();

	for $context (@stringcontexts) {
		print "extern const char *names_of_${context} [];\n";
	}

	print "\n#endif /* _MACH_CONFIG_H */\n";
}

#######################################################
#  generate build/mach-strings.c
#######################################################
elsif ($command eq "strings") {
	print $START_SOURCE;
	for $context (@stringcontexts) {
		machine_write_decl_names ($context);
	}
	print $END_SOURCE;
}

#######################################################
#  generate build/mach-switchmasks.c
#######################################################
elsif ($command eq "switchmasks") {
	print $START_SOURCE;
	my @opto_mask;
	for my $i (0..9) { $opto_mask[$i] = 0; }
	foreach $sw (unique ($m->{"switches"})) {
		if (defined $sw->{'opto'}) {
			my $num = $sw->{'number'};
			my $col = $num / 8;
			my $row = $num % 8;
			$opto_mask[$col] |= 1 << $row;
		}
	}
	print "const U8 mach_opto_mask[] = {\n   ";
	for my $i (0..9) {
		my $val = sprintf "0x%02X", $opto_mask[$i];
		print "$val, ";
	}
	print "\n};\n";

	my @edge_mask;
	for my $i (0..9) { $edge_mask[$i] = 0; }
	foreach $sw (unique ($m->{"switches"})) {
		if (defined $sw->{'edge'}) {
			my $num = $sw->{'number'};
			my $col = $num / 8;
			my $row = $num % 8;
			$edge_mask[$col] |= 1 << $row;
		}
	}
	print "const U8 mach_edge_switches[] = {\n   ";
	for my $i (0..9) {
		my $val = sprintf "0x%02X", $edge_mask[$i];
		print "$val, ";
	}
	print "\n};\n";
	print $END_SOURCE;
}

#######################################################
#  generate build/mach-lampsets.c
#######################################################
elsif ($command eq "lampsets") {
}

elsif ($command eq "dump") {
	machine_dump ();
}


