#!/usr/bin/perl
#
# Copyright 2006 by Brian Dominy <brian@oddchange.com>
#
# This file is part of FreeWPC.
#
# FreeWPC is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# FreeWPC is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with FreeWPC; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# ------------------------------------------------------------------
# fsmgen - compile a finite state machine description
# ------------------------------------------------------------------


use Data::Dumper;

# TODO:
# Optimizations:
# * If a timer is started from only one state, then the existence of 
# the timer running equates to the state being active.  Remove the state 
# from the list.  Remove the state variable if all states can be 
# eliminated this way.
# * Use a bit flag if there are only two states.
# * Merge identical code blocks, for readability

my $debug_enabled = 0;
my %states;
my %inputs;
my %transitions;
my %actions;
my $fsm_name;
my $enum_prefix;
my $timernum = 0;
my %timer_transition_from;
my %timer_duration;

sub debug {
	return if (!$debug_enabled);
	my $separator = "";
	my $function = shift;
	print OFH "          $function (";
	for $arg (@_) {
		my $arg2 = $arg;
		$arg2 =~ s/\n/\\n/g;
		print OFH "$separator\"$arg2\"";
		$separator = ", ";
	}
	print OFH ");\n";
}

sub skip {
	$_ = shift;
	return 1 if /^[ \t]*#/;
	return 0;
}

sub state_enum { 
	my ($state) = @_;
	$state =~ tr/a-z/A-Z/;
	return "${enum_prefix}_STATE_" . $state;
}

sub timer_gid {
	my $t = shift;
	my $id = $fsm_name . "_" . $t;
	$id =~ tr/a-z/A-Z/;
	return "GID_${id}";
}

sub timer_function {
	my $t = shift;
	my $id = $fsm_name . "_" . $t;
	return "${id}_task";
}

sub write_debug_functions {
	return if (!$debug_enabled);
	print OFH <<END;
#define db_print_transition(init, event, new) \\
db_puts (init); db_puts (" : "); \\
db_puts (event); db_puts (" => "); \\
db_puts (new); db_puts ("\\n")

END
}

sub fsm_finish {

	if (!$header_written) {
		print OFH "#include <freewpc.h>\n\n";
		write_debug_functions;
		$header_written++;
	}

	print OFH "/* Automatically generated from FSM $fsm_name */\n\n";

	if (!defined $states{"INIT"}) {
		print STDERR "Warning: '$fsm_name' does not define an INIT state\n";
	}

	my $fsm_state_var = "${fsm_name}_fsm_state";
	print OFH "typedef enum {\n";
	foreach $state (keys %states) {
		print OFH "   " . state_enum ($state) . ",\n";
	}
	print OFH "} ${fsm_name}_state;\n\n";

	for my $timer (1 .. $timernum) {
		print OFH "static void " . timer_function ("timer_" . $timer) . 
			" (void);\n";
	}
	print "\n";

	print OFH "static ${fsm_name}_state ${fsm_state_var};\n\n";

	foreach $input (keys %inputs) {
		if ($input =~ /^timer_/) {
			print OFH "static void " . timer_function ($input) . " (void) {\n";
			debug "db_puts", "$input is running\n";
			print OFH "   task_sleep (" . $timer_duration{$input} . ");\n";
			debug "db_puts", "$input has expired\n";
		}
		else {
			print OFH "CALLSET_ENTRY ($fsm_name, $input)\n{\n";
		}

		print OFH "   switch ($fsm_state_var) {\n";

		if (defined  $transitions{"*,$input"}) {
			foreach $state (keys %states) {
				$transitions{"$state,$input"} = $transitions{"*,$input"};
				$actions{"$state,$input"} = $actions{"*,$input"};
			}
			$transitions{"*,$input"} = undef;
			$actions{"*,$input"} = undef;
		}

		foreach $state (keys %states) {
			my $transition = $transitions{"$state,$input"};
			if (defined $transition) {
				if (($transition eq $state) && ((length values %states) == 1)) {
					print OFH "      default:\n";
				}
				print OFH "      case " . state_enum ($state) . ":\n";

				# If transition from a state in which a timer was running, then
				# stop the timer (unless we are in the timer function)
				# i.e. if $transition{state,TIME_xxx} is defined.
				for $key (keys %transitions) {
					if ($key =~ /$state,(timer_.*)/) {
						if ($1 ne $input) {
							debug "db_puts", "$1 stopped\n";
							print OFH "         task_kill_gid (" .  timer_gid ($1) .  ");\n";
						}
					}
				}
				#if (my $timers = $timer_transition_from{$state}) {
				#	for $timernum (split " ", $timers) {
				#		if ($input ne $timernum) {
				#		}
				#	}
				#}

				# If transitioning to a state that may be followed by a timer,
				# then start the timer.
				# i.e. for all timers T where $transition{$transition,T} is defined.
				for $key (keys %transitions) {
					if ($key =~ /$transition,(timer_.*)/) {
						debug "db_puts", "$1 started\n";
						print OFH "         task_recreate_gid (" . 
							timer_gid ($1) . ", " . timer_function ($1) .
							");\n";
					}
				}

				#if (my $timers = $timer_transition_from{$transition}) {
				#	for $timernum (split " ", $timers) {
				#	}
				#}

				my $action = $actions{"$state,$input"};
				if ($action ne "") {
					print OFH "         $action\n";
				}

				debug "db_print_transition", $state, $input, $transition;
				print OFH "         $fsm_state_var = " . 
					state_enum ($transition) . ";\n";
				print OFH "         break;\n";
			}
		}
		#print OFH "      default:\n";
		#print OFH "         break;\n";
		print OFH "   }\n";

		if ($input =~ /^timer_/) {
			print OFH "   task_exit ();\n";
		}
		print OFH "}\n\n";
	}
}


sub fsm_new {
	%states = ();
	%inputs = ();
	%transitions = ();
	%actions = ();
	$fsm_name = shift;
	$enum_prefix = $fsm_name;
	$enum_prefix =~ tr/a-z/A-Z/;
	$timernum = 0;
	%timer_transition_from = ();
	%timer_duration = ();
	my $in_action = 0;

	while (<IFH>) {
		next if (skip $_);
		chomp;
		s/^[ \t]+//;
		if (/^{/) {
			$in_action = 1;
		}
		elsif (/^}/) {
			if ($in_action == 1) {
				$in_action = 0;
			}
			else {
				fsm_finish;
				return;
			}
		}
		elsif (/(.*):(.*)[ \t]+=>[ \t]+(\w+)[ \t]*$/) {
			my ($init_states, $events, $new_state) = ($1, $2, $3);
			$init_states =~ s/[ \t]//g;
			$events =~ s/[ \t]//g;
			$new_state =~ s/[ \t]//g;
			@event_array = split /,/, $events;
			if ($init_states ne "*") {
				@init_state_array = split /,/, $init_states;
				foreach $init_state (@init_state_array) {
					foreach $event (@event_array) {
						if ($event =~ m/^TIME_/) {
							++$timernum;
							$timer_transition_from{$init_state} .= "timer_" . $timernum . " ";
							$timer_duration{"timer_" . $timernum} = $event;
							$event = "timer_" . $timernum;
						}

						$states{$init_state} = 1;
						$states{$new_state} = 1;
						$inputs{$event} = 1;
						$transitions{"$init_state,$event"} = $new_state;
						$actions{"$init_state,$event"} = "";
						$current_action = \$actions{"$init_state,$event"};
					}
				}
			}
			else {
				foreach $event (@event_array) {
					$inputs{$event} = 1;
					$transitions{"*,$event"} = $new_state;
					$actions{"*,$event"} = "";
					$current_action = \$actions{"*,$event"};
				}
			}
		}
		else {
			if ($in_action) {
				s/throw[ \t]+(.*);/callset_invoke ($1);/g;
				$$current_action .= $_;
			}
		}
	}
	print STDERR "Internal error: FSM '$fsm_name' did not codegen\n";
}


while (my $arg = shift @ARGV) {
	if ($arg =~ /-o/) {
		$outfile = shift @ARGV;
	}
	elsif ($arg =~ /-d/) {
		$debug_enabled = 1;
	}
	else {
		$infile = $arg;
	}
}

if (!defined $outfile) {
	$outfile = $infile;
	$outfile =~ s/\.fsm$/.c/;
}

open IFH, $infile or die "can't open $infile for reading\n";
open OFH, ">$outfile" or die "can't open $outfile for writing\n";
while (<IFH>)
{
	chomp;
	next if (skip $_);
	if (/^(\w+)[ \t]+\{$/) {
		fsm_new ($1);
	}
}

#print OFH "/*" . Dumper(%timer_transition_from) . "*/\n";
