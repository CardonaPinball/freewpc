
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_TICKS 32
#define MAX_SLOTS_PER_TICK 16
#define MAX_TASKS 64

struct include_file
{
	char name[256];
};


struct task
{
	char name[128];
	unsigned int period;
	double len;
};

struct slot
{
	unsigned int divider;
	struct task *task;
};

struct tick
{
	unsigned int n_slots;
	struct slot slots[MAX_SLOTS_PER_TICK];
	double len;
};


/* The master scheduling table */
unsigned int n_ticks = 0;
struct tick ticks[MAX_TICKS];

unsigned int n_tasks = 0;
struct task tasks[MAX_TASKS];

unsigned int max_ticks = 8;

unsigned int max_divider = 1;

const char *prefix = "tick";

unsigned int n_includes = 0;
struct include_file include_files[16];


unsigned long gcd (unsigned long a, unsigned long b)
{
	if (b == 0)
		return a;
	else
		return gcd (b, a % b);
}


unsigned long lcm (unsigned long a, unsigned long b)
{
	return (a  / gcd (a, b)) * b;
}


void write_schedule (FILE *f)
{
	unsigned int n;

	for (n=0; n < n_ticks; n++)
	{
		struct tick *tick = &ticks[n];
		unsigned int slotno;

		fprintf (f, "Tick %d - %g :\n", n, tick->len);
		for (slotno = 0; slotno < tick->n_slots; slotno++)
		{
			struct slot *slot = &tick->slots[slotno];
			fprintf (f, "   %s - %g(/%d)\n", slot->task->name, slot->task->len, slot->divider);
		}
	}
}


void write_tick_driver (FILE *f)
{
	unsigned int n;
	unsigned int div;
	const char *task_name;

	fprintf (f, "/* Automatically generated by gensched */\n");

	fprintf (f, "__attribute__((section (\"direct\"))) void (*%s_function) (void);\n\n", prefix);
	fprintf (f, "__attribute__((section (\"direct\"))) unsigned char %s_divider;\n", prefix);

	for (n=0; n < n_includes; n++)
		fprintf (f, "#include \"%s\"\n", include_files[n].name);
	fprintf (f, "\n");

	for (n=0; n < n_ticks; n++)
		fprintf (f, "static __attribute__((interrupt)) void %s_%d (void);\n", prefix, n);
	fprintf (f, "\n");

	for (n=0; n < n_ticks; n++)
	{
		struct tick *tick = &ticks[n];
		unsigned int slotno;
		unsigned int divider_count = 0;

		fprintf (f, "static __attribute__((interrupt)) void %s_%d (void)\n{\n", prefix, n);
		fprintf (f, "   /* utilization = %g */\n", tick->len);

		for (div = 1; div <= max_divider; div *= 2)
		{
			unsigned int used = 0;
			for (slotno = 0; slotno < tick->n_slots; slotno++)
			{
				struct slot *slot = &tick->slots[slotno];
				if (slot->divider == div)
				{
					if ((div > 1) && (used == 0))
					{
						fprintf (f, "   if (!(%s_divider & %d))\n   {\n", prefix, div-1);
						used = 1;
						divider_count++;
					}

					task_name = slot->task->name;
					if (*task_name == '!')
						task_name++;
					else
						fprintf (f, "   extern void %s (void);\n", task_name);
					fprintf (f, "   %s (); /* utilization = %g */\n",
						task_name, slot->task->len);
				}
			}
		}
		while (divider_count-- > 0)
			fprintf (f, "   }\n");

		if ((n == n_ticks-1) && (max_divider > 1))
		{
			fprintf (f, "   %s_divider++;\n", prefix);
		}

		if (n_ticks > 1)
		{
			fprintf (f, "   %s_function = %s_%d;\n", prefix, prefix, (n+1) % n_ticks);
		}

		fprintf (f, "}\n\n");
	}

	fprintf (f, "__attribute__((interrupt)) void %s_driver (void)\n{\n", prefix);
	fprintf (f, "   (*%s_function) ();\n", prefix);
	fprintf (f, "}\n\n");

	fprintf (f, "void %s_init (void)\n{\n", prefix);
	fprintf (f, "   %s_function = tick_0;\n", prefix);
	fprintf (f, "   %s_divider = 0;\n", prefix);
	fprintf (f, "}\n\n");
}


void init_schedule (void)
{
	n_ticks = 0;
	n_tasks = 0;
}


void expand_ticks (unsigned int new_tick_count)
{
	unsigned int tickno;

	n_ticks = 8;
	for (tickno = 0; tickno < n_ticks ; tickno++)
	{
		ticks[tickno].n_slots = 0;
		ticks[tickno].len = 0.0;
	}
}


unsigned int find_best_tick (unsigned int period, unsigned int count, double len)
{
	/* Find the best starting bucket to put a task with PERIOD and length LEN.
	COUNT such buckets will have a slot added.
		We search through all buckets and look for the bucket that is 
	least utilized. */

	unsigned int tickno, best = 0;
	double best_len = 99999.0;
	unsigned int index;

	/* printf ("find_best_tick: period %d count %d len %g\n", period, count, len);
	printf ("checking %d different starting points\n", n_ticks / count);
	printf ("adding %d different ticks for each\n", count); */

	for (tickno = 0; tickno < n_ticks / count; tickno++)
	{
		double total_len = 0.0;

		for (index = 0; index < count; index++)
		{
			double candidate_len = ticks[tickno + (n_ticks / count) * index].len;

			/* If adding this task here would cause an overflow (i.e.
			all tasks would take longer than 1 tick to finish), then
			set the cost very high, disparaging this choice. */
			if (candidate_len + len >= 1.0)
				candidate_len = 99999.0;

			/* If the period is larger than the number of ticks (i.e.
			there is a divider here), prefer the last tick for this.
			It is best if all dividers share the same bucket. */
			if ((period > n_ticks) && (tickno == n_ticks/count - 1))
				candidate_len = -1.0;

			total_len += candidate_len;
		}

		if (total_len < best_len)
		{
			best_len = total_len;
			best = tickno;
		}
	}

	/* printf ("best is %d, best_len = %g\n\n", best, best_len); */
	return best;
}


struct slot *alloc_slot (unsigned int tickno)
{
	struct tick *tick = &ticks[tickno];
	return &tick->slots[tick->n_slots++];
}


void add_task (char *name, unsigned int period, double len)
{
	unsigned int count, base;
	struct slot *slot;
	struct task *task;
	unsigned int divider = 1;

	task = &tasks[n_tasks++];
	strcpy (task->name, name);
	task->period = period;
	task->len = len;

	if (period > n_ticks)
	{
		if (period <= max_ticks)
		{
			expand_ticks (period);
			count = n_ticks / period;
		}
		else
		{
			divider = period / n_ticks;
			if (divider > max_divider)
			{
				max_divider = divider;
				/* if (max_divider >= 256) warn about overflow */
			}
			count = 1;
		}
	}
	else
	{
		count = n_ticks / period;
	}

	base = find_best_tick (period, count, len);

	while (count > 0)
	{
		slot = alloc_slot (base);
		slot->divider = divider;
		slot->task = task;

		ticks[base].len += (task->len / divider);

		base = (base + period) % n_ticks;
		count--;
	}
}


void parse_schedule (FILE *f)
{
	char name[128];
	unsigned int period;
	float len;

	for (;;)
	{
		fscanf (f, "%s %d %f\n", name, &period, &len);
		if (feof (f))
			break;
		if (*name == '#')
			continue;
		if (*name == '\0')
			continue;
		add_task (name, period, len);
	}
}


int main (int argc, char *argv[])
{
	unsigned int argn;
	FILE *outfile = stdout;

	init_schedule ();

	argn = 1;
	while (argn < argc)
	{
		if (argv[argn][0] == '-')
		{
			switch (argv[argn++][1])
			{
				case 'o':
					outfile = fopen (argv[argn], "w");
					break;

				case 'i':
					strcpy (include_files[n_includes++].name, argv[argn]);
					break;
			}
		}
		else
		{
			FILE *infile = fopen (argv[argn], "r");
			parse_schedule (infile);
			fclose (infile);
		}
		argn++;
	}

	/* add_task ("zerocross_calc", 1, 0.2);
	add_task ("switch_read", 2, 0.3);
	add_task ("flipper_write", 4, 0.7);
	add_task ("lockup_check", 128, 0.1);
	add_task ("led_toggle", 32, 0.01);
	add_task ("lamp_write", 2, 0.4); */

	write_tick_driver (outfile);
	if (outfile != stdout)
		fclose (outfile);
	return 0;
}

