# vim: set filetype=html:
[top.hti]
<div id="center" class="column">

<h1>Theory of Operation</h1>

<p>This page provides some background material as to how WPC pinball machines
work and how the FreeWPC software is architected.</p>

<p>WPC stands for <b>Williams Pinball Controller</b> and is the hardware system
that was used in all games from 1990-1999,
starting with <b>Funhouse</b> and ending with <b>Cactus Canyon</b>.

<p>Instead of a single computer controlling everything, the system was divided
into a number of boards.  The CPU board housed the 6809 processor, RAM, and
ROM, and basically drives the rest of the system.  The other boards performed
I/O functionality and were connected to the CPU board by ribbon cables.

<p>The CPU board also has an ASIC, also called the WPC chip (U6 in the
schematics), which served as an address decoder.  I/O is all memory mapped
into particular regions of the 64KB address space.  The ASIC basically
demultiplexes the address and sets the chip enables on the correct device,
be it the RAM, ROM, or one of the offboard I/O components.

<p>The WPC sound board has its own CPU, another 6809, and so most all of
the sound processing is done outside the context of the CPU board,
and therefore is outside the scope of FreeWPC.  The CPU board just single
8-bit commands to the sound board to start/stop/query sound operations,
while the sound board itself deals with the actual sound chips.

<h2>The 6809 CPU</h2>

<p>The 6809 is a 2MHz, 8-bit Motorola processor.  This means that
it can execute 2 million cycles per second.  Each assembler
instruction takes one or more cycles to complete, depending
on its complexity.  The average instruction takes 4-6 cycles.
A single cycle is 500ns long.

<p>It supports two interrupts: a normal '''IRQ''', and
a '''fast IRQ''', or '''FIRQ'''.  The difference is that
when an IRQ occurs, all registers are saved to the
stack.  The FIRQ handler must manually save any registers
that need to be preserved.  On the WPC platform, the
IRQ is driven via a crystal to fire 1024 times per second,
or about once every 976 microseconds (equivalently, once
every 1952 CPU cycles).

<p>The FIRQ is asserted by the WPC, when programmed to do so,
when the DMD controller has finished drawing a particular
scanline or when its internal timer register expires.

<p>The hardware timer is actually not used on the DMD games,
the emulators don't support it, and so FreeWPC does not use it either.

<h2>The Memory Map</h2>

<p>All memory and I/O is mapped into a unified 64KB address
space, which is the most that the 6809 can address at a time.
The 6809 reads and writes are first seen by the
WPC ASIC, which decodes the address and forwards the
request on to the correct device.

<h3>RAM</h3>
Mapped from $0000 to $1FFF, for a total of 8KB.
The WPC allows a configurable portion of the RAM 
to be write-protected; trying to write this area
without first unlocking the memory will cause
the write to be ignored.  The entire RAM is battery-backed
across system resets.

<h3>Dot Matrix Controller</h3>
Mapped from $3800 to $3BFF, for a total of 1KB.
The controller provides 16 display pages, each
512 bytes in size, but only 2 of them are mapped
into memory at a time.  The ///current low page///
is mapped at $3800, and the ///current high page///
is mapped at $3A00.  There is also an
///active page register/// which controls which
of the 16 pages is actually visible; the visible
page may or may not be mapped.

<h3>ASIC I/O</h3>
Mapped from	$3E00 to $3FFF.  This region contains all of the WPC 
memory-mapped I/O registers for reading switches, turning on lamps, etc.

More detailed descriptions of the ASIC registers are included in 
%link(Hardware Functions).

<h3>Paged ROM</h3>
Mapped from $4000 to $7FFF.  This is a 16KB window in which a portion of 
the ROM appears.  ROM varies in size and can be anywhere from 128KB to
1MB.  The WPC can be programmed to determine which 16KB section of the 
ROM appears here.

<h3>Fixed ROM</h3>
Mapped from $8000 to $FFFF.  The upper 32KB of
the ROM image is always mapped here.

<h2>Realtime Operation</h2>

Because tasks are not preemptive, they are not
guaranteed to run with any particular frequency.  For
high priority tasks, a guarantee is often required.
These types of functions are invoked from the IRQ
handler, which is called by the 6809 about once every
976 microseconds.
	
<h2>Multitasking</h2>

FreeWPC implements a round-robin, non-preemptive task
scheduler.

The minimum task granularity is defined by IRQS_PER_TICK.
Currently, this is set to 16, meaning that 1 task tick
is equal to about 16ms.  No task can request to sleep 
for less than 1 tick.  Also, no task can directly sleep
for longer than 256 ticks, because the internal task
structure stores the sleep time as an 8-bit value.
There is a higher-layer API for sleeping a certain number
of seconds, which makes repeated calls to the underlying
API to sleep 1s at a time.

If a task does not give up control, either by sleeping,
exiting, or yielding after a certain amount of time,
the fatal error '''ERR_FCFS_LOCKUP''' will be asserted.

<h2>Error Handling</h2>

The function fatal() is called from a number of places
whenever something goes really wrong.  fatal()
takes one parameter, an ///errno value///.  A call
to fatal() will lead to a reset of the machine.

The values for errno are fixed and defined in
%file(include/sys/errno.h).

A companion function, nonfatal(), is used whenever
the system can continue running.

The debugger can be used to determine more information
about what went wrong when an error is thrown.

<h2>Switch Processing</h2>

<h2>Lamp Processing</h2>

WPC supports up to 64 lamps, arranged in an 8x8 matrix.
The '''column strobe register''' identifies which of
the 8 lamp columns is currently being driven.
The '''row value register''' determines the states of
those lamps, one bit per lamp.  All lamps on other
columns remain off.

The illusion of all 64 lamps being on at once is
done by rapidly switching the column strobe.
The strobe is changed every 2ms.

<h2>Solenoid and Motor Processing</h2>

WPC supports four standard drive output registers,
with one bit per drive, for a total of 32 drives.
These are not arranged in a matrix at all, so all
solenoids can potentially be active at the same time.

The power driver board has different characteristics
for each set of drives, providing for low-power,
high-power, and general purpose solenoids.  From
the CPU's perspective, all of them are equivalent.

Two flavors of solenoid APIs are provided.  The
first lets you directly control the state of a drive.
The second allows you to specify a duty cycle period.
Then, the drive is rapidly cycled between a set of
states.  This is useful with solenoids to prevent
coil fatigue.

The flashlamp APIs are similar to the solenoid APIs,
except that they are momentary.  A flashlamp is
pulsed briefly, after which it is turned off.

<h2>Dot Matrix Display Processing</h2>

<h2>Sound Processing</h2>

<h2>Triac Processing (Flipper Relays and General Illumination</h2>

<h2>Flipper Processing</h2>

<h2>The Real-Time Clock</h2>

<h2>Bank Switching</h2>

<h2>The WPC Bit Shifter</h2>

<h2>DMD Transitions</h2>

A transition is an interim effect that runs between
the end of one display effect and the beginning of
another.  By default, a new effect will simply kill
the old one and overwrite it with a new image.

Transitions are scheduled -- a handler is installed
that runs the next time that a new image is shown.
Instead of showing the image right away, the transition
handler kicks in and displays some combination of
the present view and the new one.  When the transition
finishes, the display should consist entirely of the
new image.
				
A number of different transition types are available.

<Striping
The new image overwrites the old one in vertical
sections.  Variations include ///left to right///,
///right to left///, ///inside out///, and
///outside in///.
<Scrolling/Pushing
The new image pushes the old image off the
display.  The new image can originate from any
of the 4 edges of the display.
<Fading

<h2>The Machine Description</h2>

<h2>Events</h2>

init
start_game_attempt
start_game
add_player
start_ball
ball_in_play
ball_drain
end_ball
bonus
abort_game
end_game
amode_start
amode_stop
tilt_warning
tilt
slam_tilt
replay
high_score
grand_champion
coin_added
credit_added
start_without_credits
volume_change
ball_search
any_pf_switch
lamp_reflash

<h2>Details of the ROM creation process</h2>

<h3>Create Blank File</h3>

<p>If the ROM size is larger than the number of pages that
need to be compiled, then the final ROM image must be
padded with blanks.  The <b>dd</b> command is used
to generate a file named '''blankxxx.bin''', where <i>xxx</i>
is the size of the file in kilobytes (KB).  This file
is then concatenated with the actual game code to produce
a final ROM of the required size.

<h3>Create Linker Command Files</h3>

<p>The linker is invoked several times, once per page or
bank of ROM.  Different options are passed each time
to place the correct object file into that section, and
to resolve references correctly; all of these options
are written to linker command files, which have the .lnk
extension and are placed in the <i>build</i> directory.

<h3>Create XBM Prototypes</h3>
<p>The file <i>xbmproto.h</i> contains externs for XBMs
(simple bitmap files).

<h3>Setting the Machine Symbolic Links</h3>
<p>The symbol link <i>mach</i> is set to point to the correct
machine directory, based on the value of the MACHINE
make variable.

<h3>Generating Defines</h3>
<p>Some #defines are generally automatically by scanning the
code for uses.  These includes begin with the prefix
///gendefine/// and are created by a script also named
///gendefine/// in the ///tools/// directory.

<h3>Generating Callsets</h3>
<p>Callsets are a mechanism for implementing a simple
event subscription/invocation mechanism that is fully
described at compile-time.  Event handling code is
emitted in a C file named ///callset.c///.

<h3>Linking Pages</h3>
<p>The aslink utility is used to create one S-record file,
with the '''.s19''' extension, for each page of ROM.

<h3>Converting Pages to Binary</h3>

<p>The %file(tools/srec2bin) utility included with FreeWPC
is run to convert the S-records into raw binary files.

<h3>Concatenating Pages</h3>

<p>The binary files are concatenated, along with any blank
files, to form the final ROM image.


<div class="end"><i>&nbsp;Copyright &copy; 2007 by Brian Dominy.</i></div>

</div>

[bottom.hti]
