#!/usr/bin/perl
#
# Copyright 2007 by Brian Dominy <brian@oddchange.com>
#
# This file is part of FreeWPC.
#
# FreeWPC is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# FreeWPC is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with FreeWPC; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

my %inputs;
my @conditions;
my %outputs;
my @actions;
my $current_condition;
my $current_action;
my $condid = 0;
my $infile = "";
my $lineno = 0;
my %ExternTable;

my %FunctionTable = (
	"lamp,on" => "lamp_tristate_on",
	"lamp,off" => "lamp_tristate_off",
	"lamp,flash" => "lamp_tristate_flash",
);

my %DefaultTable = (
	"lamp" => "off"
);


sub get_output_type
{
	my $item = shift;
	if ($item =~ /^LM_/) {
		return "lamp";
	} else {
		return "???";
	}
}

sub get_input_test
{
	my $string = shift;
	$string =~ s/(FLAG_[A-Za-z0-9_]+)/flag_test ($1)/g;
	$string =~ s/(GID_[A-Za-z0-9_]+)/task_find_gid ($1)/g;
	return $string;
}

sub split_condition
{
	my $cond = shift;
	my @results;

	my @parts = split /[ \t&|!()=><+-0123456789]+/, $cond;
	for my $part (@parts) {
		if ($part ne "") {
			push @results, $part;
		}
	}

	return @results;
}


sub write_c_header
{
	print OFH "/* Automatically generated from $infile */\n\n";

	print OFH "#include <freewpc.h>\n\n";
	for $input (sort keys %inputs) {
		print OFH "extern __mux__ void change_" . $input . " (void);\n";
	}
}


sub write_c_code
{
	print OFH "/* Automatically generated from $infile */\n\n";

	print OFH "#include <freewpc.h>\n\n";

	for $ext (keys %ExternTable) {
		print OFH "extern unsigned char $ext;\n";
	}

	# Write conditions
	print OFH "\n/* Conditions */\n\n";
	for $cond (@conditions) {
		print OFH "static inline bool " . $cond->{c_ident} . " (void)\n";
		print OFH "{\n";
		print OFH "   return " . get_input_test ($cond->{cstring}) . ";\n";
		print OFH "}\n\n";
	}

	# Write output functions
	print OFH "\n/* Output functions */\n\n";
	for $output (sort keys %outputs) {
		print OFH "static inline void update_" . $output . " (void)\n";
		print OFH "{\n";
		my $ifop = "if";
		for $action (@actions) {
			if ($action->{object} eq $output) {
				my $cond = $action->{condition};
				my ($obj, $verb) = ($action->{object}, $action->{verb});
				my $type = get_output_type ($obj);
				my $function = $FunctionTable{"$type,$verb"};
				my $stmt = "$function ($obj);";
				my $condition_predicate = $cond->{c_ident};
				my $condition_text = $cond->{cstring};

				print OFH "   $ifop ($condition_predicate ()) /* $condition_text */\n";
				print OFH "      $stmt\n";
				$ifop = "else if";
			}
		}
		if ($ifop ne "if") {
			my $type = get_output_type ($output);
			my $verb = $DefaultTable{"$type"};
			my $function = $FunctionTable{"$type,$verb"};
			my $stmt = "$function ($output);";
			print OFH "   else\n";
			print OFH "      $stmt /* default */\n";
		}
		print OFH "}\n\n";
	}

	# Write input functions
	print OFH "\n/* Input functions */\n\n";
	for $input (sort keys %inputs) {
		my %affected_outputs = ();
		print OFH "void change_" . $input . " (void)\n";
		print OFH "{\n";
		for $action (@actions) {
			my $cond = $action->{condition};
			my @maybe_inputs = split_condition ($cond->{cstring});
			for $maybe_input (@maybe_inputs) {
				if ($input eq $maybe_input) {
					$affected_outputs{$action->{object}} = 1;
				}
			}
		}

		for $output (sort keys %affected_outputs) {
			print OFH "   update_" . $output . " ();\n";
		}
		print OFH "}\n\n";
	}
}


sub parse
{
	while (<IFH>)
	{
		chomp;
		$lineno++;
		s/^[\t]+//; # ignore leading whitespace
		next if (/^#/); # skip comments
		next if (/^$/); # skip blank lines

		if (/^when/)
		{
			my $cstring = $_;
			$cstring =~ s/^when[ \t]+//;

			$current_condition = {};
			$current_condition->{cstring} = $cstring;
			$current_condition->{c_ident} = "condition_$condid";
			$condid++;
			push @conditions, $current_condition;

			my @inputs = split_condition ($cstring);
			for my $input (@inputs) {
				if (!defined $inputs{$input}) {
					$inputs{$input} = 1;
					if ($input =~ /^[a-z]/) {
						$ExternTable{$input} = 1;
					}
				}
			}
		}

		else
		{
			my ($obj, $verb) = split /[ \t]+/, $_;
			$current_action = {};
			$current_action->{object} = $obj;
			$current_action->{verb} = $verb;
			$current_action->{condition} = $current_condition;
			push @actions, $current_action;

			if (!defined $outputs{$obj}) {
				$outputs{$obj} = 1;
			}
		}
	}
}

my $c_file = undef;
my $h_file = undef;

while ($arg = shift @ARGV) {
	if ($arg =~ /-o/) {
		$c_file = shift;
	}
	elsif ($arg =~ /-h/) {
		$h_file = shift;
	}
	elsif ($arg =~ /-c/) {
		$infile = shift;
		open IFH, "$infile" or die "error: cannot open input file";
	}
}

parse;

if (defined $c_file) {
	open OFH, ">$c_file" or die "error: cannot open $c_file";
	write_c_code;
	close OFH;
}

if (defined $h_file) {
	open OFH, ">$h_file" or die "error: cannot open $h_file";
	write_c_header;
	close OFH;
}

