
#include <stdio.h>
#include <string.h>


#define MAX_TICKS 32
#define MAX_SLOTS_PER_TICK 16
#define MAX_TASKS 64

struct task
{
	const char *name;
	unsigned int period;
	double len;
};

struct slot
{
	unsigned int divider;
	struct task *task;
};

struct tick
{
	unsigned int n_slots;
	struct slot slots[MAX_SLOTS_PER_TICK];
	double len;
};


/* The master scheduling table */
unsigned int n_ticks;
struct tick ticks[MAX_TICKS];

unsigned int n_tasks;
struct task tasks[MAX_TASKS];

unsigned int max_ticks = 8;

unsigned int max_divider = 1;

const char *prefix = "tick";


unsigned long gcd (unsigned long a, unsigned long b)
{
	if (b == 0)
		return a;
	else
		return gcd (b, a % b);
}


unsigned long lcm (unsigned long a, unsigned long b)
{
	return (a  / gcd (a, b)) * b;
}


void write_schedule (FILE *f)
{
	unsigned int n;

	for (n=0; n < n_ticks; n++)
	{
		struct tick *tick = &ticks[n];
		unsigned int slotno;

		fprintf (f, "Tick %d - %f :\n", n, tick->len);
		for (slotno = 0; slotno < tick->n_slots; slotno++)
		{
			struct slot *slot = &tick->slots[slotno];
			fprintf (f, "   %s - %f(/%d)\n", slot->task->name, slot->task->len, slot->divider);
		}
	}
}


void write_tick_driver (FILE *f)
{
	unsigned int n;
	unsigned int div;

	fprintf (f, "/* Automatically generated by gensched */\n");

	fprintf (f, "void (*%s_function) (void);\n\n", prefix);
	fprintf (f, "U8 %s_divider;\n", prefix);

	for (n=0; n < n_ticks; n++)
	{
		struct tick *tick = &ticks[n];
		unsigned int slotno;
		unsigned int divider_count = 0;

		fprintf (f, "static void %s_%d (void)\n{\n", prefix, n);
		fprintf (f, "   /* utilization = %f */\n", tick->len);

		for (div = 1; div <= max_divider; div *= 2)
		{
			unsigned int used = 0;
			for (slotno = 0; slotno < tick->n_slots; slotno++)
			{
				struct slot *slot = &tick->slots[slotno];
				if (slot->divider == div)
				{
					if ((div > 1) && (used == 0))
					{
						fprintf (f, "   if (%s_divider & %d)\n   {\n", prefix, div-1);
						used = 1;
						divider_count++;
					}
					fprintf (f, "   extern void %s (void);\n", slot->task->name);
					fprintf (f, "   %s (); /* utilization = %f */\n",
						slot->task->name, slot->task->len);
				}
			}
		}
		while (divider_count-- > 0)
			fprintf (f, "   }\n");

		if ((n == n_ticks-1) && (max_divider > 1))
		{
			fprintf (f, "   %s_divider++;\n", prefix);
		}

		if (n_ticks > 1)
		{
			fprintf (f, "   %s_function = %s_%d;\n", prefix, prefix, (n+1) % n_ticks);
		}

		fprintf (f, "}\n\n");
	}

	fprintf (f, "void %s_driver (void)\n{\n", prefix);
	fprintf (f, "   (*%s_function) ();\n", prefix);
	fprintf (f, "}\n\n");

	fprintf (f, "void %s_init (void)\n{\n", prefix);
	fprintf (f, "   %s_function = tick_0;\n", prefix);
	fprintf (f, "   %s_divider = 0;\n", prefix);
	fprintf (f, "}\n\n");
}


void init_schedule (void)
{
	n_ticks = 0;
	n_tasks = 0;
}


void expand_ticks (unsigned int new_tick_count)
{
	unsigned int tickno;

	n_ticks = 8;
	for (tickno = 0; tickno < n_ticks ; tickno++)
	{
		ticks[tickno].n_slots = 0;
		ticks[tickno].len = 0.0;
	}
}


unsigned int find_best_tick (unsigned int period, unsigned int count, double len)
{
	/* Find the best starting bucket to put a task with PERIOD and length LEN.
	COUNT such buckets will have a slot added.
		We search through all buckets and look for the bucket that is 
	least utilized. */

	unsigned int tickno, best = 0;
	double best_len = 99999.0;
	unsigned int index;

	printf ("find_best_tick: period %d count %d len %f\n", period, count, len);
	printf ("checking %d different starting points\n", n_ticks / count);
	printf ("adding %d different ticks for each\n", count);

	for (tickno = 0; tickno < n_ticks / count; tickno++)
	{
		double total_len = 0.0;

		for (index = 0; index < count; index++)
		{
			double candidate_len = ticks[tickno + count * index].len;

			/* If adding this task here would cause an overflow (i.e.
			all tasks would take longer than 1 tick to finish), then
			set the cost very high, disparaging this choice. */
			if (candidate_len + len >= 1.0)
				candidate_len = 99999.0;

			/* If the period is larger than the number of ticks (i.e.
			there is a divider here), prefer the last tick for this.
			It is best if all dividers share the same bucket. */
			if ((period > n_ticks) && (tickno == n_ticks/count - 1))
				candidate_len = -1.0;

			total_len += candidate_len;
		}

		if (total_len < best_len)
		{
			best_len = total_len;
			best = tickno;
		}
	}

	printf ("best is %d, best_len = %f\n\n", best, best_len);
	return best;
}


struct slot *alloc_slot (unsigned int tickno)
{
	struct tick *tick = &ticks[tickno];
	return &tick->slots[tick->n_slots++];
}


void add_task (const char *name, unsigned int period, double len)
{
	unsigned int count, base;
	struct slot *slot;
	struct task *task;
	unsigned int divider = 1;

	task = &tasks[n_tasks++];
	task->name = name;
	task->period = period;
	task->len = len;

	if (period > n_ticks)
	{
		if (period <= max_ticks)
		{
			expand_ticks (period);
			count = n_ticks / period;
		}
		else
		{
			divider = period / n_ticks;
			if (divider > max_divider)
				max_divider = divider;
			count = 1;
		}
	}
	else
	{
		count = n_ticks / period;
	}

	base = find_best_tick (period, count, len);

	while (count > 0)
	{
		slot = alloc_slot (base);
		slot->divider = divider;
		slot->task = task;

		ticks[base].len += (task->len / divider);

		base = (base + period) % n_ticks;
		count--;
	}
}


int main (int argc, char *argv[])
{
	init_schedule ();
	add_task ("zerocross_calc", 1, 0.2);
	add_task ("switch_read", 2, 0.3);
	add_task ("flipper_write", 4, 0.7);
	add_task ("lockup_check", 128, 0.1);
	add_task ("led_toggle", 32, 0.01);
	add_task ("lamp_write", 2, 0.4);
	//write_schedule (stdout);
	write_tick_driver (stdout);
	return 0;
}

